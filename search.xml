<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事务</title>
      <link href="/crazy_ll/2019/10/05/%E4%BA%8B%E5%8A%A1/"/>
      <url>/crazy_ll/2019/10/05/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务（未完成）"><a href="#事务（未完成）" class="headerlink" title="事务（未完成）"></a>事务（未完成）</h1><p>离不开了4个基本</p><ol><li><strong>原子性</strong>：操作要么成功要么失败</li><li><strong>隔离性</strong>：多个操作之间互不影响，如果没有隔离性可能多个操作交替进行，导致获取到的数据不正确，造成不正确的结果，这其实和多线程类似</li><li><strong>持久性</strong>：一旦操作完成，数据就将会被永久的保留</li><li><strong>一致性</strong>：对于金额来说，转账以后，账户上增加的和减少的金额总数应该是不变的，对于其他数据来说，应该是要符合业务约束的，所以<code>一致性</code>的定义算是满足一定约束，满足预期要求的</li></ol><p><code>事务</code>其实就是保证了上面所说4种规则的一个或者多个操作，事务是个抽象的概念</p><a id="more"></a><h2 id="事务的状态："><a href="#事务的状态：" class="headerlink" title="事务的状态："></a>事务的状态：</h2><ol><li>活动的 active</li><li>部分提交 partially committed </li><li>已提交 commited</li><li>失败 failed</li><li>终止 abort</li></ol><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191010231148.png" alt></p><p>事务在内存中修改完成后是处于<code>部分提交</code>的状态，在写入磁盘以后才处于<code>提交</code>状态</p><p>对应的遇到错误的时候处于<code>失败</code>，回滚了数据才处于<code>中止</code></p><p>只有<code>提交</code>和<code>中止</code>两个是最终状态</p><h2 id="事务在MySQL中的写法"><a href="#事务在MySQL中的写法" class="headerlink" title="事务在MySQL中的写法"></a>事务在MySQL中的写法</h2><ul><li><p><code>BEGIN</code>     </p></li><li><p><code>START TRANSACTION</code></p></li></ul><p>在<code>START TRANSACTION</code>后可以加上修饰符</p><ul><li><p><code>START TRANSACTION READ ONLY</code>  ：当前事务只读</p></li><li><p><code>START TRANSACTION READ WRITE</code>：可以读写</p></li><li><p><code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code>：启动一致性读</p></li></ul><p>其中各种条件可以通过逗号<code>,</code>连接，前两个是设置的事务的只读模式，所以只能2选1</p><p>提交事务 <code>COMMIT</code></p><p>回滚事务<code>ROLLBACK</code></p><p><code>MyISAM</code>引擎不支持事务，就算在命令中写了回滚也是无效的</p><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>MySQL中有个变量<code>autocommit</code>默认为开启，在开启的时候，每一个SQL语句都可以看做是一个单独的事务，如果需要多个SQL共同放在一个事务，就需要现实的开启事务</p><p>关闭<code>autocommit</code>的话，就需要手动提交事务</p><h2 id="隐式回滚"><a href="#隐式回滚" class="headerlink" title="隐式回滚"></a>隐式回滚</h2><ul><li>使用DDL（Data definition language）</li><li>修改表</li><li>事务控制或有锁定的语句</li><li>加载数据的语句</li><li>复制的语句</li><li>其他</li></ul><p>具体看小册</p><h2 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h2><p>在一条语句执行完后执行<code>SAVEPOINT 保存点名称</code></p><p>回滚的时候可以执行<code>ROLLBACK TO 保存点名称</code>来回滚到指定的位置</p><p>释放保存点<code>RELEASE SAVEPOINT 保存点名称</code></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Buffer Pool</title>
      <link href="/crazy_ll/2019/10/03/Buffer%20Pool/"/>
      <url>/crazy_ll/2019/10/03/Buffer%20Pool/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer-Pool（未完成）"><a href="#Buffer-Pool（未完成）" class="headerlink" title="Buffer Pool（未完成）"></a>Buffer Pool（未完成）</h1><p>对于MySQL数据库来说，每次执行一个查询语句都是从磁盘对应的文件中读取出来，然后放到内存中，但是磁盘的速度相当慢，所以每次都从磁盘读取那速度就十分堪忧了。</p><p>并且！每次访问一个记录，都需要将对应的页先全部加载到内存中</p><p>所以该如何优化？</p><p>可以把这个页的数据（页大小默认为16k），全部缓存起来，那么在下次访问的时候就可以直接读取缓存中的页数据，而不用去磁盘中加载了，那么这个缓存就叫做 <code>Buffer Pool</code></p><h2 id="Buffer-Pool格式"><a href="#Buffer-Pool格式" class="headerlink" title="Buffer Pool格式"></a>Buffer Pool格式</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191011160001.png" alt></p><a id="more"></a><p>看图说话，总共是3个部分</p><ul><li>控制块</li><li>碎片</li><li>缓存页</li></ul><p><code>缓存页</code>就是用来存储页的数据信息的，那么对于这么多缓存页肯定需要进行管理，否则怎么知道哪些页是哪个表的，在这个内存空间中的位置在哪里，页号是啥，还有一些锁信息和LSN</p><p>所以，<code>控制块</code>就是用来存储这些信息的</p><p>那一块连续的区间在设置了这两部分信息后，可能会出现有部分的空间不够分配，那就是<code>碎片</code> 了</p><h2 id="缓存后的管理问题"><a href="#缓存后的管理问题" class="headerlink" title="缓存后的管理问题"></a>缓存后的管理问题</h2><ol><li><p><strong>如何记录这一片内存空间中哪些缓存页是空的哪些是有数据的</strong></p><p>通过一个链表来保存对应的记录，称为<code>Free链表</code>如图<img src="http://py2mk0s3q.bkt.clouddn.com/20191011162711.png" alt></p><p>这个链表的基节点是保存在<code>Buffer Pool</code>空间以外的地方</p><p>那么对应的存储有数据的也相应的有一个链表来存储，叫做<code>Flush链表</code></p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191011233731.png" alt></p><p>为什么叫做<code>Flush链表</code>，因为修改是在内存中做修改的，对一个缓存页中的某些数据进行修改了以后，这个缓存页就需要重新写回磁盘，不然数据就无效了，所以把这个页标记为<code>dirty page</code>也就是<code>脏页</code>，然后刷新回磁盘，但是不可能一标记完就刷新到磁盘，所以全部放到一个<code>Flush链表</code>中，说明这些是需要刷新到磁盘的内容。</p></li></ol><ol start="2"><li><p><strong>如何定位到对应的页</strong></p><p>用散列表就OK了，将<code>表空间号+页号</code>作为key，缓存页作为value</p></li><li><p><strong>页满了怎么办</strong></p><p>满了就需要删除，那应该怎么删除？</p><p><strong>注意</strong>：现在有的数据结构是 </p><ul><li>一个free链表</li><li>一个flush链表</li><li>一个散列表也就是hash表</li></ul><p>未包含任何数据的缓存页是存储在free链表中，而已经缓存了的页是放在这个散列表中的，flush链表中的数据是待刷新到磁盘的</p><p>能直接想到的就是LRU最近最少使用来删除链表尾部的页，而有新的页加载进内存的时候则放在链表的头部</p></li></ol><ol start="4"><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL成本分析</title>
      <link href="/crazy_ll/2019/10/01/MySql%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90/"/>
      <url>/crazy_ll/2019/10/01/MySql%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="成本-未完成"><a href="#成本-未完成" class="headerlink" title="成本(未完成)"></a>成本(未完成)</h1><p>一条查询语句包含两种成本</p><ul><li>I/O成本</li><li>CPU成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构</title>
      <link href="/crazy_ll/2019/09/29/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/crazy_ll/2019/09/29/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>InnoDB在不同的目的下设计了许多不同的 <code>页</code></p><p>其中存放记录的叫做 <code>数据页</code></p><h2 id="页的结构图"><a href="#页的结构图" class="headerlink" title="页的结构图"></a>页的结构图</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009221736.png" alt></p><a id="more"></a><p>所有页都有 <code>File Header</code> <code>File Trailer</code> </p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009221753.png" alt></p><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>这个是页内快速查找所需数据的方式，就好像书本的目录，对主要章节记录了页数，<code>Page Directory</code>也是类似的功能，样子就像下图</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009222542.png" alt></p><p>由于页中的用户数据是一个单链表，在查找页中所需要的数据，比如<code>主键=8</code>，就只能通过遍历这个链表来找到这条数据，为了提高效率，就通过<code>槽(slot)</code>来实现快速查找。</p><p>这个槽其实就是一条数据，从图里也能看出来 </p><p>就是通过将数据进行分组，然后将每一组（除了最小的）最大的数据作为一个槽</p><p>InnoDB中这个分组是有规定的</p><ul><li>对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间</li></ul><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>页和页之间是通过这个<code>File Header</code>中记录上一页的页号和下一页的页号来形成一个双链表，不过并不是所有类型的页都有上下页的属性，数据页是有的</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009225234.png" alt></p><p>在Header中还有一个数据：<code>FIL_PAGE_SPACE_OR_CHKSUM</code>代表当前这个页的校验和</p><h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>数据写入mysql，是在内存中修改完页中的内容后再写入磁盘，如果这时候出现问题导致磁盘写入失败，该怎么办</p><p>所以在<code>File Trailer</code>中，前4个字节代表的也是校验和，这个和<code>Header</code>中的校验和是一致的，因为写磁盘的时候，<code>Header</code>的校验和会先同步到磁盘，这时候如果出现断电等问题，那么头尾校验和就不一致</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB的存储结构</title>
      <link href="/crazy_ll/2019/09/28/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/InnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/crazy_ll/2019/09/28/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/InnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB的存储结构"><a href="#InnoDB的存储结构" class="headerlink" title="InnoDB的存储结构"></a>InnoDB的存储结构</h1><p>数据的读取和写入都是由<font color="red" size="3"><code>存储引擎</code></font>实现的，在不同的引擎中存放的结构也一般是不相同的，比如<font color="red" size="3"><code>Memory</code></font>引擎使用内存作为持久化存储，现在主要分析<font color="red" size="3"><code>InnoDB</code></font></p><h2 id="什么是页"><a href="#什么是页" class="headerlink" title="什么是页"></a>什么是页</h2><p>InnoDB引擎是将数据记录在磁盘上，而<font color="red" size="3"><code>数据的处理是发生在内存中</code></font>，所以需要从内存中将数据写入磁盘或者将磁盘的内容加载到内存中，由于磁盘和内存的读写的速度差距，InnoDB不可能一条条记录从磁盘读取或者写入</p><p>所以，<font color="red" size="3"><code>InnoDB将数据分为若干页，以页作为磁盘和内存之间交互的基本单位，页大小一般为16KB，每16KB作一次读取或者写入</code></font></p><a id="more"></a><h2 id="什么是行格式"><a href="#什么是行格式" class="headerlink" title="什么是行格式"></a>什么是行格式</h2><p> 行格式内容过多，细节需要多去小册上回顾</p><p>以一条记录为单位将数据存储到数据库中，这些记录在磁盘上的存放方式被称为<font color="red" size="3"><code>行格式</code></font>  或者<font color="red" size="3"><code>记录格式</code></font></p><p>总共有4种</p><ul><li><font color="red" size="3"><code>Compact</code></font> </li><li><font color="red" size="3"><code>Redundant</code></font> </li><li><font color="red" size="3"><code>Dynamic</code></font> </li><li><font color="red" size="3"><code>Compressed</code></font> </li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190927170654.png" alt></p><p>在用户的数据之前还有一些其他的额外的记录信息</p><h3 id="记录额外的信息"><a href="#记录额外的信息" class="headerlink" title="记录额外的信息"></a>记录额外的信息</h3><p>服务器为了描述这条记录而必须添加的额外信息，分为3类，如上图所示</p><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>一些变长数据，<code>VARVHAR</code>,<code>VARBINARY</code>,各种<code>TEXT</code>类型,各种<code>BLOB</code>类型，因为变长的字段长度不固定，所以需要保存对应占用的字节数，在这个部分保存所有变长字段占用的长度， 并且是<font color="red" size="3"><code>逆序</code></font>存放，具体内容回顾下<code>小册第五章</code></p><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>列中可能存在NULL值，这部分值存在真实数据部分很占空间，如果允许有NULL的列，就会有NULL值的列表，如果对应的列为NULL，则会在列表对应的字节位上标记1，否则标记0，一个字节表示8列，也是<font color="red" size="3"><code>逆序</code></font>存放</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009171726.png" alt></p><p>每条记录都会指向主键大于本条记录的下一条记录，形成一个单链表，通过<code>next_record</code>来记录，<code>record_type</code>记录了类型，在一个页中，有固定的最小和最大记录，对应的值为2和3，其余为0，如果是非叶子节点则记为1，<code>n_owned</code>表示当前分组中含有的数量，最小记录只能有1条，最大记录可以有1<del>8条，其余的为4</del>8条</p><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>除了上面的列还会有一些<code>隐藏列</code></p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20191009173621.png" alt></p><p>当有主键的时候，<code>row_id</code>就不需要了</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识</title>
      <link href="/crazy_ll/2019/09/27/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/crazy_ll/2019/09/27/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190927153217.png" alt></p><a id="more"></a><ol><li><font color="red" size="3"><code>处理连接</code></font>：客户端通过<font color="red" size="3"><code>TCP/IP</code></font>，<font color="red" size="3"><code>命名管道或内存</code></font>，<font color="red" size="3"><code>Unix域套接字</code></font>来和服务器建立连接</li><li><font color="red" size="3"><code>查询缓存</code></font>：缓存在处理某些系统函数等不会命中缓存，缓存需要额外的开销来处理，所以5.7.20开始不推荐使用缓存，在8.0中将缓存删除</li><li><font color="red" size="3"><code>语法解析</code></font>：由于传的只是一段文本，所以mysql会对文本做分析，判断语法是否正确，并且把将要查询的表，还有各种查询条件都提取放到mysql内部使用的一些数据结构上</li><li><font color="red" size="3"><code>查询优化</code></font>：会对语句进行一些优化，优化的结果就是生成一个执行计划</li><li><font color="red" size="3"><code>存储引擎</code></font>：mysql把数据的存储和提取都封装到了<font color="red" size="3"><code>存储引擎</code></font>中，表的存储，怎么读取，写入都是<font color="red" size="3"><code>存储引擎</code></font>负责，不同的引擎存储的方式不同，采取的存储算法也可能不同</li></ol><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ol><li><p>mysql数据库，表，列都可以有自己的字符集和比较规则，CHARACTER SET，COLLATE。<br>字符集的记录字节长度不同</p><ul><li><font color="red" size="3"><code>ASCII</code></font> 128个字符 1个字节</li><li><font color="red" size="3"><code>GB2312</code></font> 汉字加其他 如果字符在ASCII中则是一个字节，否则就是2个字节</li><li><font color="red" size="3"><code>GBK</code></font> 在上一个字符集的基础上做了扩充</li><li><font color="red" size="3"><code>utf8</code></font> 收录了几乎所有的字符，并且在不断扩充，可变长编码，长度为1~4个字节</li></ul></li><li><p>上面的这些都可以在配置文件中修改，<font color="red" size="3"><code>my.cnf</code></font>文件 </p></li><li><p>比较规则会影响到排序的结果，所以对某个字符串列作排序的时候没有得到想象中的结果应该要考虑字符集的<font color="red" size="3"><code>比较规则</code></font>配置的是什么</p></li><li><p>如果列的字符集没有定义，则默认使用表的字符集；如果表的字符集没有定义，则使用数据库的字符集；如果数据库的字符集没有定义，则使用服务器级别的字符集</p></li><li><p>从客户端到mysql到返回，总共定义了3个字符集，这里就直接复制了</p><table><thead><tr><th><strong>系统变量</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般设置为相同的字符集避免转换</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发基石AQS的秘密</title>
      <link href="/crazy_ll/2019/09/23/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%9F%B3AQS%E7%9A%84%E7%A7%98%E5%AF%86/"/>
      <url>/crazy_ll/2019/09/23/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%9F%B3AQS%E7%9A%84%E7%A7%98%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="http://py2mk0s3q.bkt.clouddn.com/20190923222841.png" alt></p><p>接触了多线程编程以后，必不可少的会对J.U.C包下的并发工具产生好奇心，这些东西究竟是怎么实现的？比如ReentrantLock是怎么实现的？AQS是怎么实现的？又是怎么实现阻塞还有唤醒的？希望通过这篇文章来解决这些问题</p><a id="more"></a><p>先来看看Java中Synchronized是怎么实现的</p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>在Java中，Synchronized是通过Monitor实现的，而Monitor则是通过ObjectMonitor来实现的，ObjectMonitor是由C++实现的，数据结构如下：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">//_owner指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中_EntryList和_WaitSet两个队列是用来保存等待获取锁的线程</p><p>整个执行流程如图：<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190923234431.png" alt></p><p>那么类似的，在J.U.C下的AQS中，也会有类似的数据结构将需要获取锁的线程进行排列，并且在特定的锁下（公平锁，非公平锁）获取锁</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS是J.U.C包下的“基石”，我们常用的<strong>CountDownLatch，ReentrantLock，Semaphore，ThreadPoolExecutor等</strong>都用到AQS</p><p>直接来代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">                ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">                lock.lock();</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这是一段ReentrantLock的最简单的使用方式，直接通过源码开始入手AQS，跳过部分代码直接到ReentrantLock的lock()部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>if判断后面是cas设置0→1，然后再设置当前线程，这里是不是和前面的Synchronized很类似，获取到锁了以后当前的owner就设置为了获取到锁的线程</p><p>那获取不到锁的时候，就是重头戏了，acquire()方法是AQS中很核心的方法，稍后会说到这个参数1到底是什么意思</p><h2 id="acquire-的来龙去脉"><a href="#acquire-的来龙去脉" class="headerlink" title="acquire()的来龙去脉"></a>acquire()的来龙去脉</h2><p>老样子，直接上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器理解&amp;一次实践中的应用</title>
      <link href="/crazy_ll/2019/09/04/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%90%86%E8%A7%A3and%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/crazy_ll/2019/09/04/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%90%86%E8%A7%A3and%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器负责将.class文件加载到JVM内存中，当Java程序第一次使用某个类中的内容，而对应的类的字节码在内存中不存在的时候，类加载器就会去加载该类的字节码文件</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ol><li><strong>根类加载器</strong>：主要负责加载jre/lib/rt.jar相关字节码</li><li><strong>拓展类加载器</strong>：负责加载jre/lib/ext/*.jar，类加载器在JDK1.9更名为Platform CLass Loader，其父类加载器为null</li><li><strong>应用程序类加载器</strong>：负责加载用户自定义的类以及classpath环境变量所配置的jar包，在JDK1.9更名为System ClassLoader，父类加载器为ExtensionClassLoader</li><li><strong>自定义类加载器</strong>：负责加载指定的特殊目录下的字节码文件，大部分情况下，自定义类加载器只需要继承ClassLoader这个类，重写findClass()方法就可以了，因为在loadClass()方法中其实就是双亲委派的实现：<ul><li>会先检查类是否已经加载</li><li>未加载则交给父加载器加载</li><li>父加载器无法加载，则调用自身的findClass()方法来加载类</li></ul></li></ol><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><ol><li><strong>全盘加载</strong>：加载某一个.class文件的时候，默认会连同该文件依赖的.class一起加载（除非显示声明通过某个指定的类加载器加载）</li><li><strong>缓存机制</strong>：所有类加载器已经加载过的.class文件都会保存到缓存中，下次使用该.class文件的时候，JVM会优先从缓存中查找，如果没有才会去加载指定的字节码文件，这也是为什么字节码文件变化后，需要重启JVM才能看到修改的原因</li><li><strong>双亲委派</strong>：<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190923100040.png" alt></li></ol><a id="more"></a><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，都是以组合的关系来服用父加载器的代码</p><p>工作过程：一个类加载收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求时子加载器才会去尝试自己加载</p><h1 id="自定义类加载器实现内存加载类"><a href="#自定义类加载器实现内存加载类" class="headerlink" title="自定义类加载器实现内存加载类"></a>自定义类加载器实现内存加载类</h1><p>在自己工具的实现中是先通过io读取指定.java文件，然后加载到内存中</p><p>实现有几个重要步骤：</p><ol><li><strong>获取.java的string信息</strong></li><li><strong>将.java信息进行运行时的编译</strong></li><li><strong>实现类加载器去加载编译后的.class信息</strong></li></ol><p>获取string信息，直接通过nio读取类信息，转化成string类型</p><p>如何实现运行时编译：首先，JavaCompile编译是调用下面这个方法</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">run</span>(InputStream <span class="keyword">in</span>, OutputStream out, OutputStream err, <span class="built_in">String</span>... arguments)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>参数分别为：</p><ol><li>java编译器提供参数</li><li>得到java编译器的输出信息</li><li>接受编译器的错误信息</li><li>一个或者多个java源文件</li></ol><p>方法参数有输入输出流，以文件形式的都可以使用这种方式进行编译，但是编译后的文件和源文件在同一位置，并且在加载结束需要进行删除。<br>所以考虑在内存中进行加载，通过hashmap进行存储，编译完成就可以进行remove操作。</p><p>非文件形式编译：JavaCompile通过文件管理服务可以编译多种形式的源文件， 比如直接使用内存中字符串来构造的文件，或者是从数据库中读取的文件，都是由JavaFileManager来提供服务的。</p><p>通过调用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">CompilationTask getTask(Writer out,</span><br><span class="line">                            JavaFileManager fileManager,</span><br><span class="line">                            DiagnosticListener&lt;? <span class="keyword">super</span> JavaFileObject&gt; diagnosticListener,</span><br><span class="line">                            <span class="built_in">Iterable</span>&lt;<span class="built_in">String</span>&gt; options,</span><br><span class="line">                            <span class="built_in">Iterable</span>&lt;<span class="built_in">String</span>&gt; classes,</span><br><span class="line">                            <span class="built_in">Iterable</span>&lt;? <span class="keyword">extends</span> JavaFileObject&gt; compilationUnits);</span><br></pre></td></tr></table></figure><p>获取CompilationTask，上面参数中有FileManager和compilationUnits，分别为文件管理服务和所需编译的内容。</p><p>要想通过内存中的string来实现编译就得需要实现通过StandardJavaFileManager和JavaFileObject，只要实现了JavaFileObject就可以被StandardJavaFileManager识别<br>完整代码实现：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, <span class="keyword">byte</span>[]&gt; <span class="keyword">compile</span>(String javaName, String javaSrc) &#123;</span><br><span class="line">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager stdManager = compiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> (MemoryJavaFileManager manager = <span class="keyword">new</span> MemoryJavaFileManager(stdManager)) &#123;</span><br><span class="line">            JavaFileObject javaFileObject = MemoryJavaFileManager.makeStringSource(javaName, javaSrc);</span><br><span class="line">            JavaCompiler.CompilationTask <span class="keyword">task</span> = compiler.getTask(<span class="keyword">null</span>, manager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Collections.singletonList(javaFileObject));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">task</span>.<span class="keyword">call</span>())</span><br><span class="line">                <span class="keyword">return</span> manager.getClassBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现步骤</p><ol><li>先获取JavaCompiler，通过JavaCompiler获取StandardJavaFileManager </li><li>由于是基于string来编译文件，所以考虑通过map来存储类名和类string信息，因此实现MemoryJavaFileManager继承ForwardingJavaFileManager，在实例成员中额外添加了map&lt;String,byte[]&gt;来存储类名和编译后字节码信息</li><li>实现一个源码字符输入，代码如下<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">StringInputBuffer</span> <span class="keyword">extends</span> <span class="title">SimpleJavaFileObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringInputBuffer</span>(<span class="type">String</span> name, <span class="type">String</span> code) &#123;</span><br><span class="line">            <span class="keyword">super</span>(toURI(name), <span class="type">Kind</span>.<span class="type">SOURCE</span>);</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">CharBuffer</span> getCharContent(boolean ignoreEncodingErrors) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CharBuffer</span>.wrap(code);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">Reader</span> openReader() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">StringReader</span>(code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>将类String信息进行包装，并且类型为SOURCE源码类型，作为getTask方法中的参数之一传入，作为需要进行编译的java信息</p><ol start="4"><li><p>同时实现输出的方法</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取javaFile用来输出</span></span><br><span class="line"> JavaFileObject getJavaFileForOutput(Location location,</span><br><span class="line">                                        String className,</span><br><span class="line">                                        Kind kind,</span><br><span class="line">                                        FileObject sibling)</span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从上面获取的javaFile获取输出流        </span></span><br><span class="line"><span class="function">OutputStream <span class="title">openOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></li><li><p>将自定义的通过map来缓存类信息的java文件管理以及包含类String信息的java文件对象传入getTask方法，获取task，执行call方法，再通过自己闲钱实现的openOutputStream()方法，将编译后的信息写入java文件管理的map中，那么就可以获得编译后的存储于内存中hashmap上的字节码信息</p></li><li><p>获得字节码以后，就需要去加载类，那么可以实现一个自定义的类加载器</p></li><li><p>实现类加载器，只需要继承ClassLoader实现findClass()方法，然后通过defineClass方法加载类信息</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String <span class="built_in">name</span>) throws ClassNotFoundException &#123;</span><br><span class="line">          byte[] buf = classBytes.<span class="keyword">get</span>(<span class="built_in">name</span>);</span><br><span class="line">          <span class="keyword">if</span> (buf == null) &#123;</span><br><span class="line"><span class="built_in">              return</span> super.findClass(<span class="built_in">name</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          classBytes.remove(<span class="built_in">name</span>);</span><br><span class="line"><span class="built_in">          return</span> defineClass(<span class="built_in">name</span>, buf, <span class="number">0</span>, buf.<span class="built_in">length</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池全解析</title>
      <link href="/crazy_ll/2019/09/02/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/crazy_ll/2019/09/02/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>平时在处理业务的时候，我们通常会使用线程池来进行处理，那我们应该选择什么方式创建线程池，在阿里开发规范中是建议程序员显示的创建ThreadPoolSize，那么线程池应该如何配置？线程在线程池里面是怎么复用的？线程池是怎么运作的？线程池该怎么关闭比较合适？<br>接下来将会从<br><strong>线程池的创建 → 线程池的执行过程 →  线程池的关闭 →  线程池的参数如何设定</strong><br>这几个方面来解析线程池</p><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>创建无非就是new一个对象，那么传入的参数的设置就很重要，我们需要知道要设置什么样的参数来完成任务</p><ul><li>所以带着问题来看线程池的构造方法</li><li>线程池中的参数有哪些？</li><li>这些参数分别是什么意思？</li><li>参数的作用是什么？</li></ul><hr><p>在Executors里面，有4个已经设计好的线程池实现方法：</p><ul><li><em>newCachedThreadPool</em></li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171255.png" alt></p><ul><li><em>newFixedThreadPool</em></li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171515.png" alt></p><a id="more"></a><ul><li><em>newSingleThreadExecutor</em></li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171557.png" alt></p><ul><li><em>newScheduledThreadPool</em></li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171608.png" alt></p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171633.png" alt></p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171647.png" alt></p><p>最后一个newScheduledThreadPool调用了super的构造方法，看这个类继承关系，依旧是ThreadPoolExecutor，那么上述就是源码提供的一些创建线程池的方法，这些方法都是调用了ThreadPoolExecutor的构造方法，仅仅只是在方法参数上做了改变，那么我们要了解线程池就需要了解这些参数在线程池中是起到了什么作用。<br>先来看看线程池的全参构造方法</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171658.png" alt></p><p>其中有个acc参数，获取了SecurityManager，这是对运行代码的权限控制，可以自己去了解一下。</p><ol><li>corePoolSize：核心线程数，不会结束的线程，一直保持工作</li><li>maximumPoolSize：最大线程数量，线程池可以创建的最大的线程数量</li><li>keepAliveTime：线程存活时间，仅对非核心线程有效</li><li>unit：存活时间单位</li><li>workQueue：任务的阻塞队列，可以看到类型为Runnable，也就是需要执行的任务的队列</li><li>threadFactory：线程工厂，用于创建线程</li><li>rejectedExecutionHandler：拒绝策略，当线程池无法处理任务的时候，会执行拒绝策略来处理任务</li></ol><p>接下来了解一下BLockingQueue，ThreadFactory，RejectExecutionHandler，分别是什么</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171831.png" alt></p><p>一个BlockingQueue的基本方法如上图所示，在获取和添加的时候如果队列为空或者满的时候会发生等待，在线程池中起到了任务获取的作用，是一种FIFO队列</p><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171927.png" alt></p><p>线程工厂就很好理解了，可以自定义实现，在线程池的构造方法中，如果不传这个参数，那么就有默认的ThreadFactory</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171941.png" alt></p><p>对线程的名字，是否是守护线程还有优先级进行了设置，可以自己实现ThreadFactory</p><h2 id="RejectExecutionHandler"><a href="#RejectExecutionHandler" class="headerlink" title="RejectExecutionHandler"></a>RejectExecutionHandler</h2><p>拒绝策略是当线程池不能再继续接收新的任务，对这个新的任务所执行的拒绝策略<br>已经提供的拒绝策略总共有4种：</p><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>直接抛出了拒绝的错误<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919171954.png" alt></p><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>调用者执行，如果线程池没有被关闭，则使用调用者的线程来处理这条任务，否则就抛弃这条任务<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172016.png" alt></p><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>抛弃最老的一条任务，最老的一条任务就是队列中的队头的数据<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172034.png" alt></p><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>直接抛弃任务，不做任何处理<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172158.png" alt></p><h1 id="线程池的执行过程"><a href="#线程池的执行过程" class="headerlink" title="线程池的执行过程"></a>线程池的执行过程</h1><p>对于线程池执行过程，自己第一次接触之前有很多疑问：</p><ul><li>线程池的执行方式有哪些？</li><li>调用执行了以后线程池是怎么处理的？</li><li>新增了一个任务，这个任务的处理又是什么样的？</li><li>线程在线程池是怎么做到复用的？</li><li>非核心线程的销毁是怎么处理的？</li><li>关闭了线程池，线程池是怎么响应关闭的？</li></ul><p>那么接下来通过源码的阅读来一个个解决上面的问题</p><p>线程池的使用一般是execute(Runnable command)或者submit(Runnable task, T result)，execute和submit的主要区别在于submit是有一个Future的返回值，可以等待获取到线程处理的结果，并且可以通过future.get()来对异常进行处理，而execute则只是执行，先看一下代码<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172330.png" alt></p><p>使用了submit方法，随便写了一个类实现了Callable模拟计算返回了一个值，submit方法的调用流程如下</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;                      <span class="comment">//方法1</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = <span class="keyword">new</span><span class="type">TaskFor</span>(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; <span class="keyword">new</span><span class="type">TaskFor</span>(Callable&lt;T&gt; callable) &#123;   <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> FutureTask(Callable&lt;V&gt; callable) &#123;                            <span class="comment">//方法3</span></span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法3</strong>就是实例了一个FutureTask，里面包含了一个callable和state，在<strong>方法1</strong>中可以看到线程池的真正执行方法就是execute(Runnable command)，那么使用了submit和execute最终都是走的execute方法来进行任务的执行处理</p><p>大致看一下执行方法<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172438.png" alt></p><p>在1365行可以看到有个ctl.get()，那么这个ctl的作用是什么，而且后面都有通过ctl获取的值来进行判断，简单的分析一下ctl的构成</p><h2 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h2><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172455.png" alt></p><p>ctl是一个AutomicInteger的值，第395行就是生成ctl的方法，其中有两个参数</p><ol><li><p>rs：RunState，指的是当前线程池的状态，其中只有running状态是小于0的</p></li><li><p>wc：WorkerCount，指的是当前线程池中工作线程的数量</p><p>在381行，ctl的默认值为 RUNNING | 0 = 11100000 00000000 00000000 00000000，其中前3位代表的是Runstate，剩余代表的都是WorkerCount（负数存储的是补码，所以前3位是111）<br>ctl主要作用就是存储当前线程池的状态和线程数量，通过简单的方式来获取需要的数据和判断状态，其中CAPACITY代表的是线程池中最大线程数</p></li></ol><p>由于ctl表示了线程池的状态，顺便看一下线程池的状态有哪些</p><h2 id="线程池运行状态"><a href="#线程池运行状态" class="headerlink" title="线程池运行状态"></a>线程池运行状态</h2><ol><li>RUNNING：运行中状态，接受任务并且能正常处理</li><li>SHUTDOWN：关闭状态，不再接受新的任务，但是仍然处理队列中已经存在的数据，当队列中数据为空的时候可以切换到STOP</li><li>STOP：停止状态，在SHUTDOWN的基础上，interrupt当前正在执行的任务，并且结束闲置的线程，当线程数为0的时候可以切换到TIDYING</li><li>TIDYING：清理状态，在这个状态下会执行terminated，terminated是默认的空方法，可以继承ThreadPoolFactory来实现</li><li>TERMINATED：终止状态，执行完tryTerminate()方法</li></ol><h2 id="execute-方法分析"><a href="#execute-方法分析" class="headerlink" title="execute()方法分析"></a>execute()方法分析</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取当前ctl    </span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line">    <span class="comment">//获取线程数量，判断是否小于核心线程数 </span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//执行addWorker</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前线程池正在运行则offer一个任务（但是可能会失败，立即返回结果）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//重新检查ctl</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">//如果线程池不在运行就把任务remove</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))</span><br><span class="line">            <span class="comment">//调用拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//添加worker</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加worker失败则拒绝任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ctl的方法可以通过看方法名字来了解意义</p><p>大致执行流程：</p><ol><li>需要线程池来执行任务调用了执行方法，就是调用了execute或者submit</li><li>看看线程数量够不够设定的corePoolSize</li><li>不够就添加，够就看看线程池是不是还在运行，然后直接添加任务到阻塞队列</li><li>添加成功时二次检查线程池状态，如果不是运行就要删掉刚刚添加的任务并且还会尝试关闭线程池，还在运行就看看WorkerCount如果是0就添加非核心线程</li><li>如果前面添加到任务队列满了，但是任务对流已经满了，就直接添加一个非核心线程来直接处理这个任务，这步也失败了就说明当前线程数达到上限了，这个任务做不了，需要通过拒绝策略来拒绝</li></ol><h2 id="addWorker-方法分析"><a href="#addWorker-方法分析" class="headerlink" title="addWorker()方法分析"></a>addWorker()方法分析</h2><p>addWorker的代码比较长，从上面execute的执行流程来看，都没怎么对线程池状态做校验（只是判断了是否是RUNNING状态），也没有对线程中线程数量做校验（如果超过了指定的最大线程数或者有多个线程同时执行了addWorker），这些判断都会在addWorker中，那么addWorker的主要功能大概猜测一下就是：</p><ul><li>校验线程池状态</li><li>校验当前线程池线程数量是否超过最大值</li><li>添加核心或者非核心线程</li></ul><p>addWorker方法比较长，分成两块，可以对照着代码一起看，这块主要是对线程池的RunState和WorkerCount的校验</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;</span><br><span class="line">    <span class="comment">//retry标签</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋    </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">       <span class="comment">// 这里其实就是不允许add线程的情况。首先线程池要在SHUTDOWN之后的状态 </span></span><br><span class="line">       <span class="comment">// 然后线程池如果在SHUTDOWN状态并且没有firstTask并且任务队列无数据</span></span><br><span class="line">       <span class="comment">// 这种情况是不允许addWorker的，线程池已经处于关闭的状态</span></span><br><span class="line">       <span class="comment">// firstTask!=null的情况只有两种，1.在核心线程没达到规定数时，添加核心线程</span></span><br><span class="line">       <span class="comment">// 2.在任务队列满的时候，添加非核心线程直接处理任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//判断线程数量是否超过上限和指定数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//cas来增加wc的数量，成功了才能从retry标签的循环跳出，执行另一块</span></span><br><span class="line">            <span class="comment">//就算并发读到了同样的wc，在cas也只会有一个成功</span></span><br><span class="line">            <span class="comment">//真正执行add的代码    </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.<span class="built_in">get</span>();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//cas失败了以后判断线程池状态有没有变更，变更了走外循环，否则走内循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这部分代码比较好理解，判断线程池状态和线程数量来决定能不能添加线程，如果需要添加线程，得要在cas成功了以后跳出retry循环才可以真正的添加线程<br>接下来就是另一块addWorker的代码</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录worker是否启动</span></span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//worker是否add成功</span></span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//new了一个worker，worker里面包含了一个firstTask和一个由线程工厂创建的新的线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">//t就是这个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//获取线程池的锁，获取到了才能更新workers</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(ctl.<span class="built_in">get</span>());</span><br><span class="line">                <span class="comment">//重新校验状态，rs==SHUTDOWN的时候只是不接受新任务，所以firstTask==null的时候</span></span><br><span class="line">                <span class="comment">//还是可以添加worker的</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//未启动前的线程状态不能为活跃的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//workers包含了所有的worker    </span></span><br><span class="line">                    workers.<span class="built_in">add</span>(w);</span><br><span class="line">                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加成功了以后需要start线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//启动失败则回滚之前add操作改变的值</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码也不难理解，实例了一个Worker，然后获取线程池的锁，获取锁的时候必须得要重新校验，我认为的重新校验的必要性（使用的是ReentrantLock的非公平锁，当线程没有获取到锁的时候会在aqs的同步队列中等待并且调用unpark进行阻塞，由于是非公平锁，所以在等待的时候，如果有新的线程需要获取锁，就会直接尝试获取锁，这种情况下可能会导致同步队列中的线程获取到锁的时间比较久，那么此时对状态再次校验就很有必要了，因为并不清楚在阻塞到唤醒的期间，这个线程池做了什么变化，就像人睡着了醒来不清楚发生了什么一样）</p><h2 id="worker类分析"><a href="#worker类分析" class="headerlink" title="worker类分析"></a>worker类分析</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承了aqs和Runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//重点</span></span><br><span class="line">        <span class="comment">//设置成-1，就是为了防止在worker在刚刚初始化以后就被interrupt（具体在shutdown方法中）</span></span><br><span class="line">        setState(<span class="number">-1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//这个线程就是通过工厂创建的线程</span></span><br><span class="line">        <span class="comment">//this是Runnable类型，实际上就是生成的thread来执行this的run方法</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run方法跑的就是这个runWorker</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">//下面就是实现aqs的方法了</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现了获取锁的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cas更改状态0→1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁将状态state=0</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="function"><span class="keyword">return</span> <span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>; &#125;</span><br><span class="line">    <span class="comment">//中断启动以后的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的worker方法都在上面了，其中涉及到了aqs的相关内容，简单理解一下，lock和unlock就是锁和释放锁的方法，其中acquire(1)和release(1)就是指的，获取一次锁和释放一次锁，在worker中，锁是不可重入锁（就是锁只有获取一次，不可能再次获取），为什么设置为不可重入锁？这个会在后面分析。</p><p>添加完worker以后，线程是怎么执行阻塞队列中的任务呢，我们知道线程执行的是run方法，那么直接看worker的run方法，在run方法里面是直接调用了runWorker</p><h2 id="worker-runWorker-方法分析"><a href="#worker-runWorker-方法分析" class="headerlink" title="worker.runWorker()方法分析"></a>worker.runWorker()方法分析</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable <span class="keyword">task</span> = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//调用了unlock，将worker中的state：-1 -&gt; 0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//突然完成</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//任务不为空或者获取到的任务不为空，getTask是个重要的方法</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//重点：调用了lock，state=0-&gt;1</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//重新校验状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行前置方法，默认空方法，可以通过继承ThreadPoolExecutor</span></span><br><span class="line">                beforeExecute(wt, <span class="keyword">task</span>);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调task的run方法</span></span><br><span class="line">                    <span class="keyword">task</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//和之前的beforeExecute一样</span></span><br><span class="line">                    afterExecute(<span class="keyword">task</span>, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">task</span> = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//完成执行任务后解锁，state=1-&gt;0</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//worker结果后的处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在runWorker方法里面有一个while循环，这就是线程复用的实现，那么可以猜一下，阻塞队列的阻塞就在getTask方法里面</p><p>runWorker方法大致就是</p><ul><li>获取任务</li><li>检查状态</li><li>执行任务</li><li>结束任务处理</li></ul><p>在线程获取到任务的时候才会执行lock，可能会有疑惑，这里为什么需要lock，并没有多线程并发的问题，为什么需要锁？</p><p>其实这个lock的用意并不是在于锁的控制，而是来区别线程是空闲的（在阻塞队列中获取任务的过程中阻塞）还是正在执行任务的，这也是设置成不可重入的原因，因为在关闭线程池的时候会关闭空闲的线程，这时候会去尝试lock，由于是不可重入，所以只会将那些lock成功的线程interrupt，这部分在终止线程池的时候会详细分析。</p><h2 id="getTask-方法分析"><a href="#getTask-方法分析" class="headerlink" title="getTask()方法分析"></a>getTask()方法分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录poll方法是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">//检查线程池状态，如果是SHUTDOWN并且队列空了就可以结束当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">//timed其实就是时间是否有效的意思，如果允许核心线程超时或者wc大于核心线程数就有效</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//wc大于最大线程数或者超时有效并且超时了 然后还剩余有线程或者没有任务了</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//cas失败了说明有线程已经修改了ctl的值</span></span><br><span class="line">            <span class="comment">//所以需要重新走一次循环，再次获取ctl，重新判断    </span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据时间是否有效来决定用哪种方式拉取任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//超时返回null</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                <span class="comment">//如果没有数据则会阻塞，否则直接返回数据 </span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">//如果捕获到了interrupted异常则置为false重走循环</span></span><br><span class="line">            <span class="comment">//这时候可能是线程池关闭了</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下这个timed变量的取值，wc &gt; corePoolSize，是可能存在多个线程同时获取到同样的wc，然后同时判断到这一步的，但是这里值进行了一次cas来修改线程的数量，多个线程操作必然只有一个线程成功，那么其他线程将会重新开始循环，再次获取ctl的值来再次判断。</p><p>timed的值是根据wc和corePoolSize的关系决定的</p><ul><li>当允许核心线程超时的时候，这个线程池中核心线程的概念其实就没有了，不会有线程常驻了</li><li>当wc还不到corePoolSize就是线程池中的线程数量还不够的时候timed是为false的，也就是时间无效，这时候timeOut会变成true，开始阻塞等待，所以核心线程会在这不断等待任务并执行，但是从代码可以看出核心线程并不是指的特定的某个线程，而是指这个数量</li><li>当wc大于corePoolSize的时候，大于核心数量的线程在指定时间内获取不到任务就会将timeOut置为true，然后重新走一次循环，然后在22行代码处进行判断是否要结束线程</li></ul><h2 id="processWorkerExit-方法分析"><a href="#processWorkerExit-方法分析" class="headerlink" title="processWorkerExit()方法分析"></a>processWorkerExit()方法分析</h2><p>processWorkerExit()方法是worker结束的时候执行的处理</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> processWorkerExit(Worker w, <span class="built_in">boolean</span> completedAbruptly) &#123;</span><br><span class="line">    <span class="comment">//如果是突然完成，在抛出异常的时候出现</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        <span class="comment">//减少worker</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//记录执行任务的数量</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试关闭线程池，会根据状态判断    </span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//如果线程池是RUNNING或者SHUTDOWN</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//min当前线程池允许的最小线程数量</span></span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                <span class="comment">//如果min==0并且阻塞队列还有数据，至少留一个线程</span></span><br><span class="line">                <span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= <span class="built_in">min</span>)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个线程</span></span><br><span class="line">        <span class="comment">//两种情况</span></span><br><span class="line">        <span class="comment">//completedAbruptly==true</span></span><br><span class="line">        <span class="comment">//wc &lt; min，线程不够满足要求就需要添加一个</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于线程池的执行流程代码分析的已经差不多了，那么线程池的关闭是如何处理的，怎么样才能合适的关闭线程池？</p><h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>经常会使用的关闭方法有shutdown()，shutdownNow()和awaitTermination()，逐个分析</p><h2 id="shutdown-方法分析"><a href="#shutdown-方法分析" class="headerlink" title="shutdown()方法分析"></a>shutdown()方法分析</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将状态设置成SHUTDOWN，里面是个循环cas</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//interrupt空闲的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">//调用onShutDown方法，默认空方法，可以自己实现</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试关闭</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在shutdown中有个比较重要的方法interruptIdleWorkers()</p><h3 id="interruptIdleWorkers-方法分析"><a href="#interruptIdleWorkers-方法分析" class="headerlink" title="interruptIdleWorkers()方法分析"></a>interruptIdleWorkers()方法分析</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有workers</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//判断是否已经interrupted，并且尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取锁成功了就interrupt</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是interrupt全部还是只是一个</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述调用tryLock方法来尝试获取锁，对获取成功的线程执行interrupt，结合前面的runWorker一起看</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable <span class="keyword">task</span> = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//重点：调用了lock，state=0→1</span></span><br><span class="line">            w.lock();</span><br><span class="line">...</span><br><span class="line">           w.unlock();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在runWorker中，在获取到任务的时候会进行lock，就是在执行任务的worker的state=1，那么在shutdown的时候，会遍历所有workers，调用tryLock尝试将worker的state=0→1，前面也说了是不可重入的锁，所以在shutdown方法执行的时候，在runWorker中，只有正在从阻塞队列获取数据但是还未获取到的空闲线程会在shutdown的时候成功获取到锁，然后执行interrupt。</p><p>所以在线程池处于SHUTDOWN状态的时候，当前正在执行任务的线程不会被interrupt</p><p>++注意：interrupt一个线程，并不会终止线程，只是给线程打了一个标志，标记这个线程interrupted的状态是true，并且当调用了Thread.interrupted()之后会将这个标记状态清除，如果代码中不检测这个状态，那么就算调用了interrupt，线程也不会有什么影响++</p><p>所以，在调用了shutdown的时候，只有在getTask的worker才会被interrupt终止获取任务，但是终止获取任务并没有立马结束当前的worker，而是会再重新循环调用getTask，这时候会判断线程池状态是不是在SHUTDOWN之后，并且队列是否为空，成立就会将当前worker结束。</p><p>总结一下就是：</p><ul><li>调用了shutdown</li><li>线程池中等待获取任务的worker会被interrupted，获取任务有两种情况<ul><li>任务队列中没数据，阻塞等待数据，这种会直接被interrupted</li><li>任务队列中还有数据，worker会一直处理直到queue==null为止</li></ul></li><li>一旦queue==null，线程池状态为SHUTDOWN</li><li>在getTask方法中decrease 当前的workerCount，然后getTask返回null，终止当前worker</li><li>在execute方法，会判断一些状态，然后拒绝新的任务，可以自己看一下具体代码实现</li></ul><p>在处理worker关闭的时候用了aqs来区别执行状态和从queue中获取数据的状态</p><h2 id="shutdownNow-方法分析"><a href="#shutdownNow-方法分析" class="headerlink" title="shutdownNow()方法分析"></a>shutdownNow()方法分析</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这几行和ShutDown类似</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//清空所有tasks</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断workers</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//直接中断所有workers</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断所有正在执行任务的worker</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">//正在执行中的worker一定是已经调用了lock的，那么对应的state=1</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">//把queue中的任务全部移到另一个list中</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="comment">//部分BlockingQueue可能会失败</span></span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//toArray方法指定了Runnable类型</span></span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="keyword">remove</span>(r))</span><br><span class="line">                taskList.<span class="keyword">add</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在方法中将任务queue中的剩余未处理的任务全部清空并且返回出来，并且将正在执行的worker 中断</p><p>然后再看一下tryTerminate做了什么，tryTerminate方法在两种关闭线程池的方法中都有调用</p><h2 id="tryTerminate-方法分析"><a href="#tryTerminate-方法分析" class="headerlink" title="tryTerminate()方法分析"></a>tryTerminate()方法分析</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法会在任何可能终止线程池的操作里被调用</span></span><br><span class="line"><span class="comment">//比如：减少worker count，在shutdown状态remove task；</span></span><br><span class="line"><span class="keyword">final</span> void tryTerminate() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//能通过上面的判断说明线程池现在queue无数据，如果有worker则应该终止    </span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将ctl cas设置为TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//默认空方法</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行将状态变为TERMINATED</span></span><br><span class="line">                    ctl.<span class="keyword">set</span>(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于线程池的关闭</p><ul><li>调用了shutdown，将线程池状态置为SHUTDOWN，不会立刻关闭，会等待queue==null，然后将workers结束，期间不接受新任务，通过拒绝策略拒绝新任务</li><li>调用了shutdownNow，会立刻清空queue，将线程池状态置为STOP，并且开始结束线程</li></ul><p>所以当我们需要快速响应关闭的时候，可以在执行逻辑中检测interrupted标志做结束处理，然后调用shutdownNow，就可以快速退出</p><p>当我们调用shutdown的时候，可能需要一会儿才能真正将线程池关闭，因为线程池需要将queue中的任务全部执行完成才会开始结束线程</p><p>所以在代码中注释中说到</p><blockquote><pre><code>* &lt;p&gt;This method does not wait for previously submitted tasks to* complete execution.  Use {@link #awaitTermination awaitTermination}* to do that.</code></pre></blockquote><h2 id="awaitTermination-方法分析"><a href="#awaitTermination-方法分析" class="headerlink" title="awaitTermination()方法分析"></a>awaitTermination()方法分析</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待指定时间结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> awaitTermination(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//等待指定时间，或者被signal唤起或者被interrupted中断    </span></span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回boolean来确定在指定时间内线程池是否状态变更为TERMINATED</p><hr><p>那么在使用线程池的时候，我们该如何去对线程池的构造参数进行合适的设置</p><h1 id="线程池中线程数量的设置"><a href="#线程池中线程数量的设置" class="headerlink" title="线程池中线程数量的设置"></a>线程池中线程数量的设置</h1><p>正确的设置线程池的大小，需要分析计算环境，资源预算和任务的特性。</p><p>首先简单了解一下什么是CPU密集型和IO密集型</p><ul><li><p>CPU密集型：CPU的占用很高，I/O在短时间内就可以完成，而CPU还有很多运算要处理（比如一个只有计算的应用，几乎都是CPU计算，但是没有I/O）</p><ul><li>特点：进行大量的运算，消耗CPU资源</li></ul></li><li><p>IO密集型：大部分时间在等待I/O的读/写操作，CPU占用不高</p><ul><li>特点：CPU消耗少，大部分时间都在等待I/O操作的完成</li></ul></li></ul><h2 id="《JAVA并发编程实战》中给出的方式"><a href="#《JAVA并发编程实战》中给出的方式" class="headerlink" title="《JAVA并发编程实战》中给出的方式"></a>《JAVA并发编程实战》中给出的方式</h2><blockquote><p>对于计算密集的任务，在拥有 N 个处理器的系统上，当线程池大小为 N+1 时，通常能实现最优的利用率。（即使当计算密集型的线程偶尔由于页缺失故障或者其它原因而暂停时，这个“额外”的线程也能确保 CPU 的时钟周期不会被浪费。）对于包含 I/O 操作或者其它阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。要正确地设置线程池的大小,你必须估算出任务的等待时间与计算时间的比值。这种估算不需要很精确,并且可以通过一些分析或监控工具来获得。你还可以通过另一种方法来调节线程池的大小:在某个基准负载下,分别设置不同大小的线程池来运行应用程序,并观察CPU利用率的水平。<br>引用自《JAVA并发编程实战》第八章线程池的使用-8.2设置线程池的大小</p></blockquote><p>书中给出定义：<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172531.png" alt></p><p>（关于线程池的大小和队列大小，网上可以查到一个估算代码）</p><p>对于并行带来的优化效果，可以通过 Amdahl定律来计算</p><h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>阿姆达尔定律：在增加计算机资源的情况下，理论上能够实现的最高加速比，这个值取决于程序中可并行组件于串行组件所占的比重。<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190919172545.png" alt></p><blockquote><p>F假定是必须被串行执行的部分，N表示处理器数量。当N趋于无穷大时，最大的加速比趋近与1/F。<br>如果程序有50%的计算需要串行执行，那么最大加速比只能是2。在拥有10个处理器的系统中，如果有10%的部分需要串行执行，那么最高加速比为5.3（53%的使用率），在拥有100个处理器的系统中，加速比达到9.2（9%的使用率），即使有无限多的CPU也不可能为10。</p></blockquote><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>解析了线程池中比较核心的方法，对于其余线程池的方法，在理解了线程池的执行以后就显得比较简单，JDK提供的几种线程池构造方法也可以自己分析一下优缺点，线程数配置需要多方面的考量。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC过程详解(OopMap,RememberSet)</title>
      <link href="/crazy_ll/2019/08/25/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/GC%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B/"/>
      <url>/crazy_ll/2019/08/25/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/GC%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><p>在了解G1收集器的时候，看到书中描述</p><blockquote><p>分成多个Region区域的难点：Region不可能孤立。一个对象分配在某个Region中，会被堆中任意的对象发生引用关系。在判断可达性确定对象是否存活的时候，那就得需要扫描整个Java堆。这个问题不是只在G1中才有，只是在G1中更加突出。在之前的分代收集中，新生代一半比老年代小许多，新生代的收集也比老年代的频繁，回收新生代的对象也面临相同的问题，如果回收新生代也要扫描老年代的话，Minor GC的效率可能会下降不少。(在gc的时候会去扫全堆，但是通过后面的Remembered Set来避免了扫全堆)</p></blockquote><p>那么就有了疑问</p><ul><li>这个Remembered Set是什么？</li><li>确定对象是否存活不是通过GC Roots来分析调用链么，为什么会有扫描堆的概念？</li><li>这个扫描堆和GC Roots的关系是什么？</li><li>具体的GC过程是什么样子的？</li><li>分代收集如何避免扫描不需要收集的区域？</li></ul><a id="more"></a><h1 id="GC大致流程"><a href="#GC大致流程" class="headerlink" title="GC大致流程"></a>GC大致流程</h1><p>假如触发了Minor GC，这时候需要对新生代的对象进行复制，复制的前提是要知道哪些对象需要被回收，所以在这之前会对新生代的对象做可达性分析，可达性分析不是随时都可以进行的，需要等待程序运行到安全点才行，可达性分析是通过枚举GC Roots，如果没有引用到达这个对象的话，那么就会被判断为可回收，jvm真正清理一个对象需要进行两次标记（第一次标记并且筛选出实现了finalize或者finalize未执行的放入F-Queue队列由一个优先级很低线程去执行，未实现的就直接gc，而F-Queue中会进行小规模的第二次标记），jvm清理了未引用的对象以后，就可以用复制将新生代中的空间回收。</p><h2 id="保守gc-半保守gc-准确gc"><a href="#保守gc-半保守gc-准确gc" class="headerlink" title="保守gc 半保守gc 准确gc"></a>保守gc 半保守gc 准确gc</h2><p>首先，我们需要清理的是堆中的信息，堆中的数据都是引用类型，但是对于JVM来说，JVM如果不做任何额外的处理，它是无法知道内存上某个位置的数据到底是解读成什么类型。</p><h3 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h3><p>在上面所说的这种情况下，只能通过猜测来判断类型，这种就称为“==保守式GC==”，在进行GC的时候，JVM会开始从一些已知的位置（JVM栈）开始扫描内存，扫描到数据的时候会看他看起来像不像一个指针，会涉及上下边界检查，GC堆的上下边界是已知的，对齐检查，通常分配空间的时候会有对齐要求，比如说4字节对齐，如果不能被4整除那么就一定不是针织，然后递归扫描。</p><p>保守式GC的好处是实现简单，可以方便的用在对GC没有特别支持的编程语言中提供自动内存管理功能</p><p>缺点：</p><ul><li>会有部分对象本来应该死了，但是有疑似指针指向他们，逃过GC的收集</li><li>由于不知道疑似指针是否真的是指针，所以它的值都不能修改，对象就不可以移动了。有一种方式可以实现，就是采用句柄作为中间层，但是这样引用的访问速度就降低了</li></ul><p>由于JVM需要丰富的反射功能，本身就需要让对象能够了解自身的结构，而这种信息GC也可以利用，所以很少有JVM会使用完全保守式GC。</p><h3 id="半保守GC"><a href="#半保守GC" class="headerlink" title="半保守GC"></a>半保守GC</h3><p>JVM可以选择在站上不记录类型信息，而在对象上记录类型信息，但是扫描栈的时候仍然会有上面保守GC的情况，但是扫描到堆中的对象的时候，因为已经记录了类型信息，所以JVM就能判断出对象内的什么位置的数据是引用类型了，这种就称为半保守式GC，也叫根上保守（只在根上是无法判断类型）</p><p>为了支持半保守式GC，运行时需要在对象上带有足够的数据源，如果是JVM的话，这些数据可能在类加载器或者对象模型的模块里计算得到，不需要JIT的特别支持。</p><p>可以在直接使用指针来实现引用的条件下支持部分对象的移动，将能直接扫描到的对象设置为不可移动，从他们触发再扫描到的对象就可以移动了</p><p>完全保守的GC通常使用不移动对象的算法，标记-清理，半保守可以使用标记清理，也可以使用其他移动的算法</p><p>半保守对JNI调用的支持比较容易，不管是不是JNI调用，都从栈扫就可以了，但是这部分就和保守式一样，会有疑似指针的问题了。</p><h3 id="准确GC"><a href="#准确GC" class="headerlink" title="准确GC"></a>准确GC</h3><p>要实现准确GC，关键就在要能识别出这块数据是不是指针。</p><p>可以实现的几种方法：</p><ol><li>数据自身带上标记，在JVM中不常见，但是在别的语言中有提现，这种方式在半保守GC中更常见点</li><li>让编译器为方法生成特别的扫描代码，JVM中没有这么实现的</li><li>从外部记录下类型信息，存成映射表。主流JVM的实现都是这样的，==在HotSpot中将这种数据结构成为OopMap==，JRockit中叫做livemap，J9中叫做GCmap。要实现这个功能，需要解释器和JIT编译器都有相应的支持，提供足够的元数据给GC。<h2 id="oopmap是什么"><a href="#oopmap是什么" class="headerlink" title="oopmap是什么"></a>oopmap是什么</h2>使用映射表的一半有两种方式：</li><li>每次都遍历原始的映射表，一个个偏移量扫描，这种用法也叫做 <strong>解释式</strong></li><li>为每个映射表生成一个定制的扫描代码，以后每次要用映射表就直接执行生成的扫描代码，叫做 <strong>编译式</strong></li></ol><p>在HotSpot中，对象的类型里有记录自己的OopMap，记录了在对象的什么偏移量上是什么类型的数据，这些是在类加载的过程中计算得到的。</p><p>每个被JIT编译过后的方法会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，这些位置主要在：</p><ol><li>循环的末尾</li><li>方法临返回前/调用方法的call指令后</li><li>可能抛出异常的地方</li></ol><p>这种位置被称为“<strong>安全点</strong>”，之所以选择在一些特定的位置来记录OopMap是因为如果每一条指令都记录OopMap的话，那么记录的数据会很大。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能够达到区分引用的目的。<strong>因此，HotSpot中GC不是在任意位置都可以进入，而只能在safePoint进入，而仍然在解释器中执行的方法则可以通过解释器里的功能自动生成OopMap提供给GC用。</strong></p><p>OopMap平时都是压缩在内存中等到GC需要的时候才解压出来使用，HotSpot是用解释式的方式来使用OopMap，每次都是循环变量里面的项来扫描对应的偏移量。</p><p>对于Java线程中的JNI方法，既不是由JVM的解释器执行的，也不是由JVM的JIT编译期生成的，所以会缺少OopMap信息，<strong>那GC的时候遇到这样的栈帧要怎么保持准确呢？</strong></p><p>HotSpot的解决方法：所有经过JNI调用边界（调用JNI方法传入的参数，从JNI方法传回的参数）的引用都必须用句柄包装起来。JNI调用java api的时候也必须用句柄包装指针，在这种实现里，JNI方法里写的 jobject实际上不是直接指向指针对象的指针，中间有一层句柄。这样在扫描到JNI方法的时候就不需要栈帧了，只需要扫描句柄表就可以从JNI方法中访问到GC堆中的对象了，但是同时这样会有句柄的包装/拆包装的开销，是JNI方法调用比较慢的原因之一。</p><h2 id="怎么进行GC-Roots枚举以及快速枚举"><a href="#怎么进行GC-Roots枚举以及快速枚举" class="headerlink" title="怎么进行GC Roots枚举以及快速枚举"></a>怎么进行GC Roots枚举以及快速枚举</h2><h2 id="minorgc怎么做到不扫描老年代的对象"><a href="#minorgc怎么做到不扫描老年代的对象" class="headerlink" title="minorgc怎么做到不扫描老年代的对象"></a>minorgc怎么做到不扫描老年代的对象</h2><p><strong>通过Remembered Set实现</strong></p><p>假设触发了minorGC，首先枚举根节点，但是根节点的对象可能在新生代中也可能在老年代中，但是我们触发的是minorGC，并不想对老年代的对象进行收集，也就是没有必要去对老年代中的对象进行可达性分析，但是这种情况是有可能会出现的，并且这时候老年代中引用了新生代的对象，新生代的对象是不可以被回收的。</p><p>解决方法是：JVM</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器详解</title>
      <link href="/crazy_ll/2019/08/24/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/crazy_ll/2019/08/24/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>图中有7种收集器，收集器之间存在连线说明可以搭配使用，所处位置标明了是新生代还是老年代的收集器，没有最好的收集器出现，只有最合适的（到目前为止）</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190922174926.png" alt></p><a id="more"></a><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>单线程，只会使用一个CPU或者一个收集线程去完成垃圾收集工作<br>进行垃圾收集的时候，必须要暂停其他所有的工作线程直到结束<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190922174956.png" alt></p><p>这是serial收集器的大致工作流程</p><p>书中比喻：“你妈妈在给你打扫房间的时候， 肯定也会让你老老实实地在椅子上或者房间外待着， 如果她一边打扫， 你一边乱扔纸屑， 这房间还能打扫完？”</p><p>从  Serial  -&gt; Parallel  -&gt; Concurrent Mark Sweep(CMS) -&gt; Garbage First (G1,最前沿成果)，仍然没有办法完全消除用户线程的停顿时间（不包括RTSJ中的收集器）</p><p>Serial仍然是虚拟机运行在Client下的默认新生代收集器（JVM有两种运行模式Server与Client），64位下只有Server模式</p><p>优点：</p><ul><li>简单高效（和其他收集器相比），单个CPU来说，没有线程交互的开销，只做垃圾回收自然有最高的单线程收集效率，在Client下，内存不大（百兆），停顿时间在几十毫秒~100多毫秒只要不频繁发生就可以</li></ul><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>ParNew是Serial的多线程版本，除了使用多线程之外，其余行为几乎和Serial一致<br><img src="http://py2mk0s3q.bkt.clouddn.com/20190922175031.png" alt></p><p>是运行在Server模式下的虚拟机中的首选新生代垃圾回收器</p><p>其中有个与性能无关但是很重要的原因是，除了Serial以外，ParNew是唯一能和CMS合作的收集器</p><p>ParNew收集器也是使用-XX： +UseConcMarkSweepGC选项后的默认新生代收集器， 也可以使用-XX+UseParNewGC选项来强制指定它</p><p>ParNew在单CPU的环境下绝对不会比Serial有更好的效果，存在线程交互的开销，在两个CPU的情况下效果都不能百分百超过Serial</p><p>ParNew默认开启的线程数和CPU数量相同</p><p>有个重要的概念区别（在垃圾收集器的上下文语境中）：</p><ul><li>并行：多条垃圾收集线程并行工作，用户线程仍然处于等待状态</li><li>并发：用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），用户程序在继续运行，垃圾收集程序运行在另一个CPU上<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2></li><li>新生代收集器</li><li>复制算法</li><li>并行的多线程收集</li></ul><p>特别之处：这个收集器的关注点和其他收集器不同，CMS等收集器是尽可能的缩短垃圾收集时候用户的停顿时间，而Parallel Scavenge是达到一个可控制的吞吐量</p><p>吞吐量：CPU用于用户代码的时间与CPU总消耗时间的比值，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，垃圾收集消耗1分钟，吞吐量就是99%</p><p>停顿时间越短越适合和用户交互的程序，高吞吐量可以高效的利用CPU的时间，尽快完成任务，适合在后台运算不需要太多交互的任务</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量， 分别是控制最大垃圾收集停顿时间的-XX：</p><p>MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX： GCTimeRatio参数。</p><p>MaxGCPauseMillis：允许大于0的毫秒数，收集器会尽可能的保证内存回收话费的时间不超过设定的时间，GC停顿时间是以牺牲吞吐量和新生代空间换取的，如果缩小新生代，那么会导致回收更频繁，虽然时间下降了，但是次数多了，吞吐量还是下降了</p><p>GCTimeRatio：0~100的整数，参数如果为19，最大GC占总时间为5%（1/(1+19)），默认99</p><p>本收集器也叫 吞吐量优先收集器，还有一个参数+UseAdaptiveSizePolicy，打开这个参数以后就不需要手工指定细节参数了，虚拟机会根据运行情况收集性能监控信息动态调整参数，称为GC自使用的调节策略</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><ul><li>是Serial的老年代版本</li><li>单线程收集器，使用 标记-整理 算法</li><li>主要是Client模式的虚拟机使用</li><li>在Server模式下有两大用途：<ul><li>在jdk5以及之前的版本与Parallel Scavenge收集器搭配使用</li><li>作为CMS收集器的后备原，在并发收集发生Concurrent Mode Failure时使用</li></ul></li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190922175056.png" alt></p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><ul><li>是Parallel Scavenge的<strong>老年代</strong>版本</li><li>多线程，<strong>标记-整理算法</strong></li></ul><p>在1.6之前，新生代选择了Parallel Scavenge，老年代就只能选择Serial Old，但是Serial Old在服务端应用性能上的拖累，导致使用了Parallel Scavenge也未必能达到吞吐量最大化的效果，在老年代很大而且硬件比较高级的场景下，这种组合的吞吐量都不一定有ParNew+CMS好。</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190922175115.png" alt></p><p>在1.6之后，吞吐量组合（Parallel Scavenge/Parallel Old），在注重吞吐量的以及CPU资源敏感的场景，都可以考虑使用这个组合。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS(Concurrent Mark Sweep):以获取最短回收停顿时间为目标的收集器。</p><p>目前大部分在互联网或者B/S系统的服务端上，十分重视服务的相应速度，希望停顿的时间最短，CMS就很适合这类应用。</p><p>CMS的运作过程比较复杂，有4个步骤：</p><ol><li>初始标记(initial mark)</li><li>并发标记(concurrrent mark)</li><li>重新标记(remark)</li><li>并发清除(concurrent sweep)</li></ol><p>其中，<strong>初始标记</strong>和<strong>重新标记</strong>需要 Stop The World 。<br>初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。<br>并发标记是进行GC RootsTracing的过程，<strong>重新标记</strong>则是修正并发标记期间因用户程序继续运作而导致标记变动的部分对象的标记记录，这部分停顿时间比1来的长远比2来的短</p><p>并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以总体上来说CMS收集器的回收过程是与用户线程一起并发执行的。<br>下图可以清楚的看到CMS的运作和停顿时间</p><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190922180408.png" alt></p><p>但是CMS也有3个很明显的缺点</p><ul><li><strong>对CPU资源非常敏感</strong>：默认的回收线程数是（N+3）/4</li><li><strong>无法处理浮动垃圾</strong>：在并发清理阶段，由于和用户线程同时进行，这一部分垃圾只能在下次GC时清理，这部分就称为‘浮动垃圾’，由于收集期间用户线程还需要运行，所以就需要预留有足够的内存给用户使用，在1.6中，CMS启动的阈值提升到92%，如果运行期间内存无法满足需要，就会出现“Concurrent Mode Failure”，这时候会使用Serial Old来重新进行老年代收集，停顿时间就更长了，所以说参数-XX： CM SInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure” 失败， 性能反而降低。</li><li><strong>标记-清除</strong>：在收集结束会有大量空间碎片产生，当给大对象分配空间的时候，可能会触发一次Full GC，解决这个问题有两个参数：<strong>+UseCMSCompactAtFullCollection</strong>开关参数（默认就是开启的） ， 用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程， 内存整理的过程是无法并发的， 空间碎片问题没有了， 但停顿时间不得不变长。 虚拟机设计者还提供了另外一个参数-XX：<strong>CMSFullGCsBeforeCompaction</strong>， 这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0， 表示每次进入Full GC时都进行碎片整理） 。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>特点：</p><ul><li>并发与并行：充分利用了硬件优势，使用多个CPU来缩短停顿时间，将其他收集器需要停顿线程的GC动作变为铜鼓并发的方式让程序继续执行</li><li>分代收集：G1可以独自管理整个GC堆，能用不同的方式去处理新，老对象</li><li>空间整合：整体看是 标记-整理 ，局部来看是基于 复制 ，这也说明了G1在收集的过程中不会出现碎片，保证有足够的连续空间可以分配</li><li>可预测的停顿：G1和CMS一样关注降低停顿时间，G1还可以建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间内，消耗在垃圾收集上的时间不能超过N毫秒</li></ul><p>使用G1收集器，Java堆的内存布局和其他的收集器有很大的差别，他把整个Java堆划分成了多个大小相等的独立区域(Region)，虽然还有新生代和老年代的概念，但是不再是物理隔离，他们都是一部分Region(不需要连续)的集合。</p><p>G1可以预测停顿时间是因为它可以有计划的<strong>避免在在整个Java堆中进行全区域的垃圾收集</strong>。G1会跟踪每个Region中垃圾堆积的价值大小(回收所获得的空间大小及回收所需要的时间)，在后台维护一个优先列表，每次根据允许的收集时间，<strong>优先回收价值最大的Region</strong>，这也是Garbage-First的名字由来。这种<strong>Region划分内存空间以及优先级区域回收的方式，保证了G1在有限时间内可以获取尽可能高的收集效率</strong>。</p><p>分成多个Region区域的难点：Region不可能孤立。一个对象分配在某个Region中，会被堆中任意的对象发生引用关系。在判断可达性确定对象是否存活的时候，那就得需要扫描整个Java堆。这个问题不是只在G1中才有，只是在G1中更加突出。在之前的分代收集中，新生代一半比老年代小许多，新生代的收集也比老年代的频繁，回收新生代的对象也面临相同的问题，如果回收新生代也要扫描老年代的话，Minor GC的效率可能会下降不少。(在gc的时候会去扫全堆，但是通过后面的Remembered Set来避免了扫全堆)</p><p>Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是<strong>使用“Remembered Set”来避免全堆扫描</strong>。<strong>每个Region都有一个对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作的时候，会产生Write Barrier 暂时中断写操作，检查Reference引用的对象是否处在不同的Region中(分代中就是检查老年代是否引用了新生代的对象)，是的话就通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中</strong>，回收时，在GC根节点枚举范围中加入Remembered Set就可以保证不扫全堆也不会有漏。</p><p>G1收集器的运作可以分为：</p><ul><li><strong>初始标记</strong>（Initial Marking）：初始标记只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start），让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但是耗时很短。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，耗时长，但是可以和用户线程并发执行。</li><li><strong>最终标记</strong>（Final Marking）：修正并发标记期间用户线程继续运行导致标记产生变动的一部分标记，jvm会将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把这里面的数据整合到Remembered Set中，需要停顿线程，但是可以并行执行。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：先对各个Region的回收价值和成本进行排序，根据用户希望的GC停顿时间来制定回收计划，这个阶段根据Sun公司透露的信息来看也可以做到并发执行，但是因为只回收一部分的Region，时间是用户可以控制的，而且停顿用户，所以停顿用户线程将大幅提高效率。</li></ul><p><img src="http://py2mk0s3q.bkt.clouddn.com/20190922180438.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化方式</title>
      <link href="/crazy_ll/2019/07/20/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/crazy_ll/2019/07/20/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="持久化种类"><a href="#持久化种类" class="headerlink" title="持久化种类"></a>持久化种类</h1><p>由于redis的数据是存储在内存中，为了保证可靠性，防止数据在redis宕机的时候全部丢失，所以有redis的持久化机制。<br>redis的持久化有两种：</p><ul><li><strong>RDB</strong>（Redis Data Base）</li><li><strong>AOF</strong>（Append Only File）</li></ul><a id="more"></a><h2 id="RDB（Redis-Data-Base）"><a href="#RDB（Redis-Data-Base）" class="headerlink" title="RDB（Redis Data Base）"></a>RDB（Redis Data Base）</h2><p>对某个时间点的一次全量数据备份，是二进制的文件，在存储上很紧凑。</p><p>RDB的触发机制：</p><ul><li>手动触发</li><li>自动触发</li></ul><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>通过命令save来触发RDB快照，save命令有同步和异步</p><p>save命令：会阻塞当前服务器，直到RDB全部完成，如果redis数据量很大的话会造成长时间的阻塞。</p><p>bgsave命令：执行该命令主进程会fork出一个子进程来完成RDB的过程，完成后自动结束，其中使用了操作系统的多进程Copy On Write，由于fork子进程是一个重量级的操作，所以在for的过程会导致阻塞，但是阻塞的时间比save短很多。</p><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><ol><li>save命令的配置：save <seconds> <changes> 在seconds时间内触发了changes次的操作会触发bgsave</changes></seconds></li><li>执行shutdown停止服务器的时候，如果没有开启AOF，会自动执行一次bgsave</li><li>主从同步：当slaver连接到master的时候，会发送SYNC，master会执行bgsave，并将该时间段下的写操作全部缓存记录下来，等全量备份完成后向slaver发送RDB，slaver会丢弃之前所有的旧数据，加载当前RDB，在master发送完RDB的时候会发送缓存的写命令，slaver接受命令同步数据</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li>执行bgsave的时候，redis会检查是否有子进程在执行RDB/AOF持久化任务，有的话直接返回</li><li>如果没有的话，redis会fork一个子进程来执行RDB操作，fork会对主进程造成阻塞，影响redis的读写，fork完成后会发送消息给主进程，不再阻塞主进程（阻塞仅是fork子进程的过程，后续进程执行操作不会阻塞）</li><li>RDB子进程会根据redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照替换原来的RDB，这个过程中，主进程的读写不受到影响，但是redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本</li><li>子进程完成RDB后发消息给主进程，通知RDB完成，将内存副本中的增量写数据同步到主内存</li></ol><h3 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h3><p>优点：</p><ol><li>文件小，非常适合定时备份，灾难恢复</li><li>加载RDB比AOF来的快，因为RDB记录的是实际的数据，AOF则是需要重放的命令<br>缺点：</li><li>无法做到实时持久化，会丢失两次RDB之间的数据</li><li>fork子进程属于重量级操作，会阻塞主进程</li><li>RDB文件格式存在新老版本不兼容的情况</li></ol><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><p>AOF日志是增量的备份，基于写命令存储的文本文件，AOF会持续不断的增大，当redis重启的时候会根据AOF进行恢复，如果AOF文件过大，那么恢复时间会很长，所以需要定期重写AOF，减小AOF的大小（毕竟是不断的顺序写，数据量只会增多）</p><p>AOF默认关闭，需要配置开启</p><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><blockquote><p>##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  </p></blockquote><p>##只有在“yes”下，aof重写/文件同步等特性才会生效<br>appendonly yes  </p><p>##指定aof文件名称<br>appendfilename appendonly.aof  </p><p>##指定aof操作中文件同步策略，有三个合法值：always，everysec，no,默认为everysec<br>appendfsync everysec  </p><p>##在aof-rewrite期间，appendfsync是否暂缓文件同步，”no”表示“不暂缓”，“yes”表示“暂缓”，默认为“no”<br>no-appendfsync-on-rewrite no  </p><p>##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”<br>auto-aof-rewrite-min-size 64mb  </p><p>##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  </p><p>##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)</p><p>##aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。<br>auto-aof-rewrite-percentage 100</p><p>AOF是在文件中添加写命令，对于操作密集的server会造成io的压力，linux也有延迟写入的手段，每次写都是在buffer中操作，当buffer数据到达一定值的时候才会触发实际写入</p><p>always：每一条AOF记录都立即同步到文件，性能很低，但是较为安全<br>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式，如果遇到物理故障，可能导致最多1秒的AOF记录丢失<br>no：redis永不直接调用文件同步，而是让操作系统来决定什么时候同步磁盘，性能较好，但是不安全</p><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>重写并不是基于原AOF重写，而是全量遍历内存中数据，逐个序列化到AOF中，在重写的过程中，所有的写命令（触发了AOF过程中的写命令）也会被记录到原AOF，同时也会在新的AOF完成之后添加进去，在全部都完成之后会重新命名并替换原AOF文件。</p><h3 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h3><p>优点：</p><ol><li>只需要追加，所以速度快，消耗的内存低<br>缺点：</li><li>AOF会过大，需要定期瘦身</li><li>由于是命令重放，所以恢复速度比RDB慢</li><li>文件比RDB大</li></ol><h1 id="一般的持久化策略"><a href="#一般的持久化策略" class="headerlink" title="一般的持久化策略"></a>一般的持久化策略</h1><ul><li>master关闭持久化</li><li>slaver开启RDB，必要的时候AOF和RDB都开启</li></ul><p>该策略适应于大部分场景，绝大部分集群</p><h2 id="为什么是绝大部分场景"><a href="#为什么是绝大部分场景" class="headerlink" title="为什么是绝大部分场景"></a>为什么是绝大部分场景</h2><p>这种设置存在的部分的数据丢失的可能性，redis的主从复制是异步的，master执行客户端请求的命令会立即返回给呵护短，然后通过异步的方式同步给slaver，因此可能在数据还没有同步给slaver的时候就宕机了，然后slaver变成了master，那么数据就丢失了。</p><p>绝大部分场景都可以容忍部分数据的丢失。</p><h2 id="为什么这样做"><a href="#为什么这样做" class="headerlink" title="为什么这样做"></a>为什么这样做</h2><p>无论哪种方式都会影响redis的性能，导致redis线程阻塞，为了保证最佳性能，将master的持久化关闭</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>AOF和RDB，优先使用AOF<br>如果开启了AOF，那么一定会优先使用AOF去恢复，即使AOF文件不存在，就会创建一个空的AOF文件</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis过期策略和内存淘汰</title>
      <link href="/crazy_ll/2019/07/14/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/crazy_ll/2019/07/14/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>过期策略的实现有两种：</p><ol><li>定期删除</li><li>惰性删除</li></ol><a id="more"></a><h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>redis每隔100ms会从设置了超时时间的key中随机抽取一部分来检查是否过期，过期就删除，如果有多余25%的key被删除就重复这个过程</p><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>定期删除可能会导致大部分的key在过期之后没有被删除，所以出现了惰性删除，惰性删除是在查询在key的时候，判断是否过期，如果过期就删除</p><h1 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h1><p>reids通过定期删除和惰性删除仍然会导致有大部分的key在过期之后没有被删除，如果不采取其他操作会导致内存溢出，所以当内存容量到达上限或者配置的maxmemory的时候就会触发内存淘汰机制</p><h2 id="内存淘汰机制-1"><a href="#内存淘汰机制-1" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>一共有6种</p><ol><li>noeviction：内存到达限制并且客户端尝试去执行需要占用过多内存的命令时返回错误</li><li>allKeys-lru：回收最少使用的key（lru：最近最少使用算法）</li><li>volatile-lru：回收设置了过期时间的key，使用lru</li><li>allKeys-random：随机删除key</li><li>volatile-random：对有设置了过期时间的key进行随机删除</li><li>volatile-ttl：对设置了过期时间的key按照最短存活时间进行删除</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
